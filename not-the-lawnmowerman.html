<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wigglydoom â€” not the Lawnmower Man</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="style-ntlm.css">
</head>
<body>
  <header><a class="back-link" href="index.html">ğŸ‘ˆ wigglydoom</a>
    <h1>Not the Lawnmower Man</h1>
  </header>

  <div id="controls">
    <div id="status-bar">
      <span id="status-text">loading modelâ€¦</span>
      <span id="backend-badge" style="display:none">GPU</span>
    </div>

    <button id="start-btn" disabled>start camera</button>
    <button id="drop-btn" disabled>drop dots</button>
    <button id="game-btn" disabled>play bite game</button>

    <label>
      <span>color</span>
      <select id="colorMode">
        <option value="rainbow">rainbow</option>
        <option value="pinkpurple">pink / purple</option>
        <option value="goldmagenta">gold / blue</option>
        <option value="cyanlime">cyan / lime</option>
      </select>
    </label>

    <label>
      <span>wiggle intensity</span>
      <input type="range" id="rippleIntensity" min="0" max="100" step="0.1" value="0">
    </label>

    <label>
      <span>wiggle speed</span>
      <input type="range" id="rippleSpeed" min="0" max="20" step="0.5" value="0">
    </label>

    <label>
      <span>gradient start</span>
      <input type="range" id="gradientStart" min="-4" max="4" step="0.1" value="-2">
    </label>

    <label>
      <span>gradient end</span>
      <input type="range" id="gradientEnd" min="-4" max="4" step="0.1" value="2">
    </label>

    <label>
      <span>dot size</span>
      <input type="range" id="pointSize" min="1" max="16" step="0.5" value="3">
    </label>

    <label>
      <span>dot density</span>
      <input type="range" id="dotDensity" min="0.1" max="10" step="0.1" value="4">
    </label>

    <label>
      <span>zoom</span>
      <input type="range" id="zoom" min="1" max="15" step="0.1" value="1.5">
    </label>

    
  </div>

  <!-- â”€â”€ Game HUD â”€â”€ -->
  <div id="game-hud">
    <div id="hud-top">
      <span id="hud-score">score: 0</span>
      <span id="hud-lives">â¤ï¸â¤ï¸â¤ï¸</span>
      <button id="hud-exit-btn">exit</button>
    </div>
    <div id="hud-mouth">open mouth to bite</div>
  </div>

  <!-- â”€â”€ Game overlay (start / game-over) â”€â”€ -->
  <div id="game-overlay">
    <div id="overlay-title">BITE IT</div>
    <div id="overlay-sub">Food flies past your face.<br>Open your mouth wide to bite it before it escapes!</div>
    <div id="overlay-score-line" style="display:none"></div>
    <div id="overlay-buttons">
      <button id="overlay-btn">start game</button>
      <button id="exit-btn">exit game</button>
    </div>
  </div>

  <!-- â”€â”€ Laser HUD (visible during game) â”€â”€ -->
  <div id="laser-label" style="display:none">LASER</div>
  <div id="laser-bar-wrap" style="display:none">
    <div id="laser-bar-fill"></div>
  </div>

  <!-- â”€â”€ Flash overlays â”€â”€ -->
  <div id="miss-flash"></div>
  <div id="bite-flash"></div>
  <div id="laser-flash"></div>

  <!-- Hidden webcam feed; MediaPipe reads video frames directly -->
  <video id="webcam" playsinline autoplay muted style="display:none"></video>

  <!-- Three.js loaded as a global UMD build (no bundler needed) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

  <script type="module">
    // Face landmark detection: MediaPipe Tasks Vision (WebGPU delegate)
    // Note: Transformers.js v3 does not yet expose a face-landmarks pipeline;
    // MediaPipe provides the same WebGPU acceleration path in the browser.
    import { FaceLandmarker, FilesetResolver }
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

    // THREE is set on window by the UMD script above and is accessible here.

    // â”€â”€ Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // â”€â”€ Scene / Camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.z = 1.5;

    // â”€â”€ Lights (for 3D food meshes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(2, 3, 4);
    scene.add(dirLight);
    const rimLight = new THREE.DirectionalLight(0xff66cc, 0.3);
    rimLight.position.set(-2, -1, 2);
    scene.add(rimLight);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // â”€â”€ Wiggle shader (adapted from globe.html) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Changes vs globe.html:
    //   â€¢ pointSize is now a uniform (controllable via slider)
    //   â€¢ Fragment shader discards corners to render circular dots
    //   â€¢ voiceMode / mouthYPosition removed (not needed for live face)
    const shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time:            { value: 0 },
        colorMode:       { value: 0 },
        rippleSpeed:     { value: 0.0 },
        rippleIntensity: { value: 0.0 },
        gradientStart:   { value: -2.0 },
        gradientEnd:     { value: 2.0 },
        pointSize:          { value: 3.0 },
        expressionColor:    { value: new THREE.Color(0, 0, 0) },
        expressionStrength: { value: 0.0 },
      },
      vertexShader: /* glsl */`
        uniform float time;
        uniform float rippleSpeed;
        uniform float rippleIntensity;
        uniform float pointSize;

        varying vec3  vPosition;
        varying float vColorFactor;

        void main() {
          vPosition = position;

          float frequency  = 2.0;
          float waveHeight = 0.1 * rippleIntensity;
          float wave =
            sin(frequency * position.x + time * rippleSpeed) *
            sin(frequency * position.y + time * rippleSpeed) *
            sin(frequency * position.z + time * rippleSpeed);

          vec3 displaced = position * (1.0 + wave * waveHeight);

          vColorFactor = wave;

          gl_Position  = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
          gl_PointSize = pointSize;
        }
      `,
      fragmentShader: /* glsl */`
        uniform float time;
        uniform int   colorMode;
        uniform float gradientStart;
        uniform float gradientEnd;
        uniform vec3  expressionColor;
        uniform float expressionStrength;

        varying vec3  vPosition;
        varying float vColorFactor;

        vec3 rainbow(float t) {
          vec3 a = vec3(0.5, 0.5, 0.5);
          vec3 b = vec3(0.5, 0.5, 0.5);
          vec3 c = vec3(1.0, 1.0, 1.0);
          vec3 d = vec3(0.00, 0.33, 0.67);
          return a + b * cos(6.28318 * (c * t + d));
        }

        void main() {
          // Soft radial glow: bright core fading to transparent edge
          vec2  coord = gl_PointCoord - vec2(0.5);
          float dist  = dot(coord, coord);
          if (dist > 0.25) discard;
          // Alpha: full brightness at centre, smooth fade toward rim
          float alpha = 1.0 - smoothstep(0.04, 0.25, dist);

          float t = time * 0.5;
          vec3  color;

          if (colorMode == 0) {
            color = rainbow(vColorFactor + t);
          } else if (colorMode == 1) {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.5, 0.0, 1.0), vec3(1.0, 0.161, 0.765), g);
          } else if (colorMode == 2) {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.0, 0.522, 1.0), vec3(0.996, 0.788, 0.255), g);
          } else {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.0, 1.0, 1.0), vec3(0.5, 1.0, 0.0), g);
          }

          color = mix(color, expressionColor, expressionStrength);
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      depthWrite:  false,
    });

    // â”€â”€ Dynamic geometry pre-allocated for density up to 10Ã— (478 Ã— 10 = 4780) â”€
    const BASE_LANDMARKS = 478;
    const MAX_COPIES     = 10;
    const MAX_EXTRA      = BASE_LANDMARKS * (MAX_COPIES - 1); // 4302 extra slots
    const MAX_LANDMARKS  = BASE_LANDMARKS + MAX_EXTRA;        // 4780 total

    const posArray = new Float32Array(MAX_LANDMARKS * 3);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    geometry.setDrawRange(0, 0);  // empty until first detection

    // Pre-baked random values for barycentric sampling â€” 5 floats per extra slot:
    //   [0] landmark index selector  [1] neighbor-1 selector  [2] neighbor-2 offset
    //   [3] barycentric r1           [4] barycentric r2
    // Generated once so extra dots sit at stable positions and follow face movement.
    const randBuf = new Float32Array(MAX_EXTRA * 5);
    for (let i = 0; i < randBuf.length; i++) randBuf[i] = Math.random();

    // Adjacency list built from FaceLandmarker.FACE_LANDMARKS_TESSELATION after
    // the model loads. adjacency[i] = array of landmark indices connected to i.
    let adjacency = null;

    function buildAdjacency() {
      const conn = FaceLandmarker.FACE_LANDMARKS_TESSELATION;
      adjacency = Array.from({ length: BASE_LANDMARKS }, () => []);
      for (const { start, end } of conn) {
        if (start < BASE_LANDMARKS && end < BASE_LANDMARKS) {
          adjacency[start].push(end);
          adjacency[end].push(start);
        }
      }
    }

    const dots = new THREE.Points(geometry, shaderMaterial);
    scene.add(dots);

    // â”€â”€ UI â†’ uniform wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const colorMap = { rainbow: 0, pinkpurple: 1, goldmagenta: 2, cyanlime: 3 };

    document.getElementById('colorMode').addEventListener('input', e => {
      shaderMaterial.uniforms.colorMode.value = colorMap[e.target.value] ?? 0;
    });
    document.getElementById('rippleIntensity').addEventListener('input', e => {
      // Divide by 10 to match globe.html's scaling convention
      shaderMaterial.uniforms.rippleIntensity.value = parseFloat(e.target.value) / 10.0;
    });
    document.getElementById('rippleSpeed').addEventListener('input', e => {
      shaderMaterial.uniforms.rippleSpeed.value = parseFloat(e.target.value);
    });
    document.getElementById('gradientStart').addEventListener('input', e => {
      shaderMaterial.uniforms.gradientStart.value = parseFloat(e.target.value);
    });
    document.getElementById('gradientEnd').addEventListener('input', e => {
      shaderMaterial.uniforms.gradientEnd.value = parseFloat(e.target.value);
    });
    document.getElementById('pointSize').addEventListener('input', e => {
      shaderMaterial.uniforms.pointSize.value = parseFloat(e.target.value);
    });

    let dotDensity = 4.0;
    document.getElementById('dotDensity').addEventListener('input', e => {
      dotDensity = parseFloat(e.target.value);
    });

    document.getElementById('zoom').addEventListener('input', e => {
      camera.position.z = parseFloat(e.target.value);
    });

    // â”€â”€ MediaPipe Face Landmarker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const statusEl  = document.getElementById('status-text');
    const badgeEl   = document.getElementById('backend-badge');
    const startBtn  = document.getElementById('start-btn');
    const dropBtn   = document.getElementById('drop-btn');
    const gameBtn   = document.getElementById('game-btn');

    let faceLandmarker = null;
    let modelReady     = false;

    async function initDetector() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );

        const modelOptions = {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU",
          },
          runningMode:                 "VIDEO",
          numFaces:                    1,
          minFaceDetectionConfidence:  0.5,
          minFacePresenceConfidence:   0.5,
          minTrackingConfidence:       0.5,
          outputFaceBlendshapes:       true,
        };

        // iOS < 17.4 has no WebGPU â€” GPU delegate throws instead of falling back.
        // Try GPU first; on failure retry with CPU so the model still loads.
        try {
          faceLandmarker = await FaceLandmarker.createFromOptions(vision, modelOptions);
          badgeEl.textContent   = 'GPU';
          badgeEl.style.display = 'inline';
        } catch (_gpuErr) {
          console.warn('[face-dots] GPU delegate failed, retrying with CPU', _gpuErr);
          modelOptions.baseOptions.delegate = "CPU";
          faceLandmarker = await FaceLandmarker.createFromOptions(vision, modelOptions);
          badgeEl.textContent   = 'CPU';
          badgeEl.style.display = 'inline';
        }

        buildAdjacency();
        modelReady           = true;
        statusEl.textContent = 'ready â€” click start camera';
        startBtn.disabled    = false;

      } catch (err) {
        statusEl.textContent = 'model error: ' + err.message;
        console.error('[face-dots] MediaPipe init failed', err);
      }
    }

    // â”€â”€ Webcam â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const video = document.getElementById('webcam');

    startBtn.addEventListener('click', async () => {
      startBtn.disabled    = true;
      startBtn.textContent = 'camera on';
      statusEl.textContent = 'requesting cameraâ€¦';
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' },
          audio: false,
        });
        video.srcObject = stream;
        // Call play() immediately â€” before any further awaits â€” so it remains
        // within the user-gesture call stack that iOS Safari requires for autoplay.
        video.play().catch(() => {});
        await new Promise(resolve => { video.onloadeddata = resolve; });
        statusEl.textContent = 'detectingâ€¦';
        dropBtn.disabled = false;
        gameBtn.disabled = false;
        detectionLoop();
      } catch (err) {
        statusEl.textContent = 'camera error: ' + err.message;
        startBtn.disabled    = false;
        startBtn.textContent = 'retry camera';
      }
    });

    // â”€â”€ Expression â†’ color mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Three expressions are tracked via MediaPipe blendshape scores [0..1]:
    //   smile    â†’ green   (mouthSmileLeft + mouthSmileRight average)
    //   mad      â†’ red     (browDownLeft   + browDownRight   average)
    //   surprisedâ†’ yellow  (browInnerUp    + jawOpen         average)
    // The dominant expression above threshold 0.15 drives expressionColor.
    // Strength and color LERP toward their targets each detection frame so
    // transitions feel smooth (~8% per frame at 30fps inference).
    let currentExprStrength = 0.0;
    const currentExprColor  = new THREE.Color(0, 0, 0);
    const targetExprColor   = new THREE.Color(0, 0, 0);
    let   targetExprStrength = 0.0;

    // â”€â”€ Live jaw/mouth state (read by game) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let jawOpenScore  = 0;   // 0..1 from MediaPipe blendshape
    let mouthWorldX   = 0;   // Three.js world coords of mouth centre
    let mouthWorldY   = 0;
    let mouthHalfW    = 0.18; // half-width of mouth bounding box (world units)
    let mouthHalfH    = 0.12;

    // â”€â”€ Live blink / eye / nose state (read by laser) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let blinkLeft     = 0;
    let blinkRight    = 0;
    let eyeMidWorld   = new THREE.Vector3();
    let leftEyeWorld  = new THREE.Vector3();
    let rightEyeWorld = new THREE.Vector3();
    let noseTipWorld  = new THREE.Vector3();
    let aimDir        = new THREE.Vector3(0, 0, -1);

    function applyExpressions(categories) {
      const bs = {};
      for (const cat of categories) bs[cat.categoryName] = cat.score;

      jawOpenScore = bs.jawOpen ?? 0;
      blinkLeft   = bs.eyeBlinkLeft  ?? 0;
      blinkRight  = bs.eyeBlinkRight ?? 0;

      const smile     = ((bs.mouthSmileLeft ?? 0) + (bs.mouthSmileRight ?? 0)) * 0.5;
      const mad       = ((bs.browDownLeft   ?? 0) + (bs.browDownRight   ?? 0)) * 0.5;
      const surprised = ((bs.browInnerUp    ?? 0) + (bs.jawOpen         ?? 0)) * 0.5;

      const dominant = Math.max(smile, mad, surprised);

      if (dominant > 0.15) {
        targetExprStrength = Math.min(dominant * 1.5, 0.8);
        if (smile >= mad && smile >= surprised) {
          targetExprColor.setRGB(0.0, 1.0, 0.3);
        } else if (mad >= surprised) {
          targetExprColor.setRGB(1.0, 0.1, 0.1);
        } else {
          targetExprColor.setRGB(1.0, 0.85, 0.1);
        }
      } else {
        targetExprStrength = 0.0;
      }

      const lerp = 0.08;
      currentExprStrength += (targetExprStrength - currentExprStrength) * lerp;
      currentExprColor.lerp(targetExprColor, lerp);

      shaderMaterial.uniforms.expressionColor.value.copy(currentExprColor);
      shaderMaterial.uniforms.expressionStrength.value = currentExprStrength;
    }

    // Update mouth world position from landmarks each frame
    function updateMouthPos(landmarks) {
      if (!landmarks) return;
      const videoAspect = (video.videoWidth && video.videoHeight)
        ? video.videoWidth / video.videoHeight : 4 / 3;
      // 13=upper-lip-centre 14=lower-lip-centre 61=left-corner 291=right-corner
      const pts = [13, 14, 61, 291].map(i => landmarks[i]);
      const avgX = pts.reduce((s, p) => s + p.x, 0) / pts.length;
      const avgY = pts.reduce((s, p) => s + p.y, 0) / pts.length;
      mouthWorldX = (0.5 - avgX) * 4 * videoAspect;
      mouthWorldY = (0.5 - avgY) * 4;
      // Mouth width from corners
      const lx = (0.5 - landmarks[61].x) * 4 * videoAspect;
      const rx = (0.5 - landmarks[291].x) * 4 * videoAspect;
      mouthHalfW = Math.abs(lx - rx) * 0.55;
      // Mouth height scales with jawOpen
      mouthHalfH = 0.05 + jawOpenScore * 0.25;

      // Helper to convert MediaPipe landmark to Three.js world space
      const getPt = (i) => new THREE.Vector3(
        (0.5 - landmarks[i].x) * 4 * videoAspect,
        (0.5 - landmarks[i].y) * 4,
        -landmarks[i].z * 4
      );

      // Eye origins for laser spawning
      leftEyeWorld.copy(getPt(159));
      rightEyeWorld.copy(getPt(386));
      eyeMidWorld.copy(leftEyeWorld).add(rightEyeWorld).multiplyScalar(0.5);

      // Calculate true 3D face normal
      const ptTop = getPt(10);  // Forehead
      const ptBot = getPt(152); // Chin
      const p234  = getPt(234); // Left cheek (anatomical)
      const p454  = getPt(454); // Right cheek (anatomical)

      // Ensure ptL is screen-left, ptR is screen-right
      const ptL = p234.x < p454.x ? p234 : p454;
      const ptR = p234.x > p454.x ? p234 : p454;

      const vVert = new THREE.Vector3().subVectors(ptTop, ptBot).normalize(); // Points UP
      const vHorz = new THREE.Vector3().subVectors(ptR, ptL).normalize();     // Points RIGHT
      
      // Cross product gives normal pointing OUT toward the camera (+Z)
      const normal = new THREE.Vector3().crossVectors(vHorz, vVert).normalize();

      // Laser shoots INTO the screen (-Z). Amplify X/Y for gameplay responsiveness.
      aimDir.set(
        normal.x * 3.5,
        normal.y * 3.5,
        -Math.abs(normal.z)
      ).normalize();
    }

    // â”€â”€ Inference loop (decoupled from render loop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // detectForVideo is synchronous but fast on GPU â€” we guard with lastVideoTime
    // so we only run inference when a new video frame is actually available.
    let latestLandmarks = null;
    let lastVideoTime   = -1;
    let noFaceCount     = 0;

    function detectionLoop() {
      if (modelReady && video.readyState >= 2 && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        try {
          const result = faceLandmarker.detectForVideo(video, performance.now());
          if (result.faceLandmarks && result.faceLandmarks.length > 0) {
            latestLandmarks    = result.faceLandmarks[0];  // array of 478 {x,y,z}
            noFaceCount        = 0;
            statusEl.textContent = 'detectingâ€¦';
            if (result.faceBlendshapes?.[0]?.categories) {
              applyExpressions(result.faceBlendshapes[0].categories);
            }
            updateMouthPos(latestLandmarks);
          } else {
            noFaceCount++;
            if (noFaceCount === 30) statusEl.textContent = 'no face detected';
            if (noFaceCount > 60) {
              // Let dots fade out â€” stop updating geometry
              latestLandmarks = null;
              geometry.setDrawRange(0, 0);
              geometry.attributes.position.needsUpdate = true;
            }
          }
        } catch (_) {
          // Per-frame errors (e.g., during video seek) are ignored
        }
      }
      requestAnimationFrame(detectionLoop);
    }

    // â”€â”€ Landmark â†’ Three.js world coordinates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MediaPipe normalizes x/y to [0,1] (x: leftâ†’right, y: topâ†’bottom).
    // z is a relative depth value, negative when closer to camera.
    // We map to Three.js world space centered on the origin:
    //   x: mirrored (selfie convention â€” your left is left on screen)
    //   y: flipped  (image y=0 is screen top; Three.js y=0 is center)
    //   z: negated  (MediaPipe near = negative z â†’ Three.js near = positive z)
    //
    // dotDensity < 1 â†’ subsample: stride through landmarks, fewer total dots
    // dotDensity > 1 â†’ barycentric super-sample on the face mesh surface:
    //   For each extra point, pick a landmark + two of its mesh-connected
    //   neighbors, then sample a uniformly random point inside that triangle.
    //   This spreads dots over the face surface proportional to local area,
    //   rather than clumping extra copies on top of already-dense landmarks.
    //   Pre-baked randBuf ensures stable positions that track face movement.
    function updateDots(landmarks) {
      let count = 0;

      // Correct for video pixel aspect ratio so face proportions are accurate.
      // MediaPipe normalises x to [0,1] over videoWidth and y over videoHeight.
      // Without correction, a 640Ã—480 feed makes faces appear ~33% too narrow.
      const videoAspect = (video.videoWidth && video.videoHeight)
        ? video.videoWidth / video.videoHeight
        : 4 / 3;

      if (dotDensity <= 1.0) {
        // Subsample: step through landmarks at stride = 1/density
        const stride = 1 / dotDensity;
        for (let f = 0; f < landmarks.length; f += stride) {
          const lm = landmarks[Math.floor(f)];
          posArray[count * 3 + 0] =  (0.5 - lm.x) * 4 * videoAspect;
          posArray[count * 3 + 1] =  (0.5 - lm.y) * 4;
          posArray[count * 3 + 2] = -lm.z           * 4;
          count++;
        }
      } else {
        // Always write all base landmarks first
        for (let i = 0; i < landmarks.length; i++) {
          const lm = landmarks[i];
          posArray[count * 3 + 0] =  (0.5 - lm.x) * 4 * videoAspect;
          posArray[count * 3 + 1] =  (0.5 - lm.y) * 4;
          posArray[count * 3 + 2] = -lm.z           * 4;
          count++;
        }

        if (adjacency) {
          const extraCount = Math.min(
            Math.floor((dotDensity - 1) * landmarks.length),
            MAX_EXTRA
          );

          for (let e = 0; e < extraCount && count < MAX_LANDMARKS; e++) {
            const rb = e * 5;

            // Pick base landmark and two distinct mesh-connected neighbors
            const i    = Math.floor(randBuf[rb]     * landmarks.length) % landmarks.length;
            const nbrs = adjacency[i];
            if (!nbrs || nbrs.length < 2) continue;

            const ni = Math.floor(randBuf[rb + 1] * nbrs.length) % nbrs.length;
            let   nj = Math.floor(randBuf[rb + 2] * (nbrs.length - 1)) % (nbrs.length - 1);
            if (nj >= ni) nj++;  // ensure ni â‰  nj

            const a = landmarks[i];
            const b = landmarks[nbrs[ni]];
            const c = landmarks[nbrs[nj]];

            // Uniform barycentric sampling via the sqrt trick:
            //   t1 + t2 + t3 = 1, distributed uniformly over the triangle
            const sqR = Math.sqrt(randBuf[rb + 3]);
            const t1  = 1 - sqR;
            const t2  = sqR * (1 - randBuf[rb + 4]);
            const t3  = sqR *      randBuf[rb + 4];

            posArray[count * 3 + 0] =  (0.5 - (a.x * t1 + b.x * t2 + c.x * t3)) * 4 * videoAspect;
            posArray[count * 3 + 1] =  (0.5 - (a.y * t1 + b.y * t2 + c.y * t3)) * 4;
            posArray[count * 3 + 2] = -(      a.z * t1 + b.z * t2 + c.z * t3)    * 4;
            count++;
          }
        }
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.setDrawRange(0, count);
    }

    // â”€â”€ BITE GAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const JAW_THRESHOLD = 0.38;  // jawOpen score needed to register a bite

    const biteSound = new Audio('sounds/bite.mp3');
    biteSound.volume = 0.7;
    function playBiteSound() {
      biteSound.currentTime = 0;
      biteSound.play().catch(() => {});
    }

    // â”€â”€ 3D Food Builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function makeFoodApple() {
      const group = new THREE.Group();
      const bodyGeo = new THREE.SphereGeometry(0.15, 12, 10);
      bodyGeo.scale(1, 1.1, 1);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe03030, roughness: 0.35, metalness: 0.05 });
      group.add(new THREE.Mesh(bodyGeo, bodyMat));
      const stemGeo = new THREE.CylinderGeometry(0.012, 0.015, 0.07, 6);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0x5c3a1e });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.16;
      group.add(stem);
      const leafGeo = new THREE.SphereGeometry(0.04, 6, 4);
      leafGeo.scale(1, 0.3, 0.6);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
      const leaf = new THREE.Mesh(leafGeo, leafMat);
      leaf.position.set(0.03, 0.16, 0);
      leaf.rotation.z = -0.5;
      group.add(leaf);
      return group;
    }

    function makeFoodDonut() {
      const group = new THREE.Group();
      const torusGeo = new THREE.TorusGeometry(0.11, 0.055, 12, 20);
      const torusMat = new THREE.MeshStandardMaterial({ color: 0xd4943a, roughness: 0.5 });
      group.add(new THREE.Mesh(torusGeo, torusMat));
      const icingGeo = new THREE.TorusGeometry(0.11, 0.045, 12, 20, Math.PI);
      const icingMat = new THREE.MeshStandardMaterial({ color: 0xff7eb3, roughness: 0.3 });
      const icing = new THREE.Mesh(icingGeo, icingMat);
      icing.rotation.x = Math.PI * 0.5;
      icing.position.y = 0.02;
      group.add(icing);
      return group;
    }

    function makeFoodBurger() {
      const group = new THREE.Group();
      const bunGeo = new THREE.SphereGeometry(0.14, 10, 8);
      bunGeo.scale(1, 0.5, 1);
      const bunMat = new THREE.MeshStandardMaterial({ color: 0xd4943a, roughness: 0.6 });
      const topBun = new THREE.Mesh(bunGeo, bunMat);
      topBun.position.y = 0.06;
      group.add(topBun);
      const bottomBun = new THREE.Mesh(bunGeo.clone(), bunMat);
      bottomBun.position.y = -0.06;
      bottomBun.scale.y = 0.7;
      group.add(bottomBun);
      const pattyGeo = new THREE.CylinderGeometry(0.13, 0.13, 0.035, 12);
      const pattyMat = new THREE.MeshStandardMaterial({ color: 0x5c3322, roughness: 0.7 });
      const patty = new THREE.Mesh(pattyGeo, pattyMat);
      group.add(patty);
      const lettuceGeo = new THREE.CylinderGeometry(0.14, 0.12, 0.02, 10);
      const lettuceMat = new THREE.MeshStandardMaterial({ color: 0x55cc44, roughness: 0.5 });
      const lettuce = new THREE.Mesh(lettuceGeo, lettuceMat);
      lettuce.position.y = 0.025;
      group.add(lettuce);
      return group;
    }

    function makeFoodPizza() {
      const group = new THREE.Group();
      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.lineTo(-0.13, -0.22);
      shape.lineTo(0.13, -0.22);
      shape.closePath();
      const extrudeSettings = { depth: 0.03, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 2 };
      const sliceGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const sliceMat = new THREE.MeshStandardMaterial({ color: 0xf5c842, roughness: 0.5 });
      const slice = new THREE.Mesh(sliceGeo, sliceMat);
      slice.position.y = 0.08;
      group.add(slice);
      const sauceGeo = new THREE.CircleGeometry(0.04, 8);
      const sauceMat = new THREE.MeshStandardMaterial({ color: 0xcc2222 });
      for (let i = 0; i < 3; i++) {
        const dot = new THREE.Mesh(sauceGeo, sauceMat);
        dot.position.set((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.08 - 0.04, 0.04);
        group.add(dot);
      }
      return group;
    }

    function makeFoodStrawberry() {
      const group = new THREE.Group();
      const bodyGeo = new THREE.ConeGeometry(0.1, 0.22, 10);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xdd2244, roughness: 0.4 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.x = Math.PI;
      group.add(body);
      const leafGeo = new THREE.ConeGeometry(0.08, 0.04, 6);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
      const leaves = new THREE.Mesh(leafGeo, leafMat);
      leaves.position.y = 0.12;
      group.add(leaves);
      return group;
    }

    function makeFoodAvocado() {
      const group = new THREE.Group();
      const bodyGeo = new THREE.SphereGeometry(0.13, 10, 10);
      bodyGeo.scale(0.8, 1.2, 0.6);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4a7a2e, roughness: 0.5 });
      group.add(new THREE.Mesh(bodyGeo, bodyMat));
      const pitGeo = new THREE.SphereGeometry(0.055, 8, 8);
      const pitMat = new THREE.MeshStandardMaterial({ color: 0x7a5c2e, roughness: 0.4 });
      const pit = new THREE.Mesh(pitGeo, pitMat);
      pit.position.z = 0.06;
      group.add(pit);
      return group;
    }

    function makeFoodLemon() {
      const group = new THREE.Group();
      const bodyGeo = new THREE.SphereGeometry(0.12, 10, 10);
      bodyGeo.scale(1.3, 1, 1);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf5e642, roughness: 0.35 });
      group.add(new THREE.Mesh(bodyGeo, bodyMat));
      const tipGeo = new THREE.ConeGeometry(0.03, 0.04, 6);
      const tipMat = new THREE.MeshStandardMaterial({ color: 0xe0d030 });
      const tipL = new THREE.Mesh(tipGeo, tipMat);
      tipL.rotation.z = Math.PI / 2;
      tipL.position.x = 0.15;
      group.add(tipL);
      const tipR = new THREE.Mesh(tipGeo.clone(), tipMat);
      tipR.rotation.z = -Math.PI / 2;
      tipR.position.x = -0.15;
      group.add(tipR);
      return group;
    }

    function makeFoodIceCream() {
      const group = new THREE.Group();
      const coneGeo = new THREE.ConeGeometry(0.09, 0.2, 10);
      const coneMat = new THREE.MeshStandardMaterial({ color: 0xc8a050, roughness: 0.6 });
      const cone = new THREE.Mesh(coneGeo, coneMat);
      cone.position.y = -0.06;
      group.add(cone);
      const scoopGeo = new THREE.SphereGeometry(0.1, 10, 10);
      const scoopMat = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.3 });
      const scoop = new THREE.Mesh(scoopGeo, scoopMat);
      scoop.position.y = 0.1;
      group.add(scoop);
      return group;
    }

    const FOOD_BUILDERS = [
      makeFoodApple,
      makeFoodDonut,
      makeFoodBurger,
      makeFoodPizza,
      makeFoodStrawberry,
      makeFoodAvocado,
      makeFoodLemon,
      makeFoodIceCream,
    ];

    const gameOverSound = new Audio('sounds/gameover.mp3');
    gameOverSound.volume = 0.7;
    function playGameOverSound() {
      gameOverSound.currentTime = 0;
      gameOverSound.play().catch(() => {});
    }

    let gameState   = 'idle';  // idle | playing | gameover
    let gameScore   = 0;
    let gameLives   = 10;
    let gameObjects = [];      // active food meshes
    let spawnTimer  = 0;
    let spawnInterval = 120;   // frames between spawns (decreases with score)
    let gameSpeed   = 0.022;   // world units per frame
    let biteOnCooldown = false;

    const hudEl        = document.getElementById('game-hud');
    const hudScoreEl   = document.getElementById('hud-score');
    const hudLivesEl   = document.getElementById('hud-lives');
    const overlayEl    = document.getElementById('game-overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySub   = document.getElementById('overlay-sub');
    const overlayScore = document.getElementById('overlay-score-line');
    const overlayBtn   = document.getElementById('overlay-btn');
    const exitBtn      = document.getElementById('exit-btn');
    const hudExitBtn   = document.getElementById('hud-exit-btn');
    const missFlash    = document.getElementById('miss-flash');
    const biteFlashEl  = document.getElementById('bite-flash');

    // Show start overlay once camera is running
    gameBtn.addEventListener('click', () => {
      overlayTitle.textContent = 'BITE IT';
      overlaySub.textContent   = 'Food flies past your face.\nOpen your mouth wide to bite it before it escapes!';
      overlaySub.style.whiteSpace = 'pre-line';
      overlayScore.style.display  = 'none';
      overlayBtn.textContent      = 'start game';
      overlayEl.classList.add('visible');
      gameState = 'idle';
    });

    overlayBtn.addEventListener('click', () => {
      startGame();
    });

    function exitGame() {
      gameState = 'idle';
      gameObjects.forEach(o => scene.remove(o.mesh));
      gameObjects = [];
      hudEl.style.display = 'none';
      showLaserHUD(false);
      overlayEl.classList.remove('visible');
    }

    exitBtn.addEventListener('click', exitGame);
    hudExitBtn.addEventListener('click', exitGame);

    function startGame() {
      gameScore     = 0;
      gameLives     = 3;
      gameObjects.forEach(o => scene.remove(o.mesh));
      gameObjects   = [];
      spawnTimer    = 0;
      spawnInterval = 120;
      gameSpeed     = 0.011;
      biteOnCooldown = false;
      updateHUD();
      overlayEl.classList.remove('visible');
      hudEl.style.display = 'block';
      showLaserHUD(true);
      gameState = 'playing';
    }

    function endGame() {
      gameState = 'gameover';
      gameObjects.forEach(o => scene.remove(o.mesh));
      gameObjects = [];
      hudEl.style.display = 'none';
      showLaserHUD(false);
      overlayTitle.textContent       = 'GAME OVER';
      overlaySub.textContent         = 'Better luck next time!';
      overlayScore.style.display     = 'block';
      overlayScore.textContent       = `score: ${gameScore}`;
      overlayBtn.textContent         = 'play again';
      overlayEl.classList.add('visible');
      playGameOverSound();
    }

    function updateHUD() {
      hudScoreEl.textContent = `score: ${gameScore}`;
      hudLivesEl.textContent = 'â¤ï¸'.repeat(gameLives) || 'ğŸ’€';
    }

    function disposeGroup(group) {
      group.traverse(child => {
        if (child.isMesh) {
          child.geometry.dispose();
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
      });
    }

    function spawnFood() {
      const builder = FOOD_BUILDERS[Math.floor(Math.random() * FOOD_BUILDERS.length)];
      const mesh    = builder();

      // Spawn off-screen left or right, spread across full vertical range
      const fromLeft = Math.random() < 0.5;
      const spawnX   = fromLeft ? -3.5 : 3.5;
      const spawnY   = (Math.random() - 0.5) * 3.0;  // -1.5 to +1.5 world units
      mesh.position.set(spawnX, spawnY, 0.1);

      // Random spin axis for tumble effect
      const spinX = (Math.random() - 0.5) * 0.06;
      const spinY = (Math.random() - 0.5) * 0.06;
      const spinZ = (Math.random() - 0.5) * 0.06;

      scene.add(mesh);
      gameObjects.push({
        mesh,
        vx: fromLeft ? gameSpeed : -gameSpeed,
        spinX, spinY, spinZ,
        scored: false,
        missed: false,
      });
    }

    function triggerMissFlash() {
      missFlash.classList.add('flash');
      setTimeout(() => missFlash.classList.remove('flash'), 200);
    }
    function triggerBiteFlash() {
      biteFlashEl.classList.add('flash');
      setTimeout(() => biteFlashEl.classList.remove('flash'), 180);
    }
    function spawnScorePop(screenX, screenY) {
      const el = document.createElement('div');
      el.className   = 'score-pop';
      el.textContent = '+1';
      el.style.left  = `${screenX}px`;
      el.style.top   = `${screenY}px`;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 750);
    }

    // Convert Three.js world XY â†’ screen pixels
    function worldToScreen(wx, wy) {
      const v = new THREE.Vector3(wx, wy, 0);
      v.project(camera);
      return {
        x: (v.x * 0.5 + 0.5) * window.innerWidth,
        y: (-v.y * 0.5 + 0.5) * window.innerHeight,
      };
    }

    // â”€â”€ LASER WEAPON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const BLINK_THRESHOLD  = 0.45;
    const LASER_COOLDOWN   = 30;   // frames (~0.5s at 60fps)
    const LASER_BEAM_LEN   = 28;   // Increased from 18 to extend way off-screen
    const LASER_VISIBLE_MS = 150;

    let laserCooldown   = 0;
    let blinkWasOpen    = true;  // debounce: must open eyes before next shot
    let activeLaserMesh = null;
    let laserFadeTimer  = null;

    const laserFlashEl  = document.getElementById('laser-flash');
    const laserBarWrap  = document.getElementById('laser-bar-wrap');
    const laserBarFill  = document.getElementById('laser-bar-fill');
    const laserLabelEl  = document.getElementById('laser-label');
    const laserRaycaster = new THREE.Raycaster();
    laserRaycaster.near = 0;
    laserRaycaster.far  = LASER_BEAM_LEN;

    function showLaserHUD(show) {
      laserBarWrap.style.display = show ? 'block' : 'none';
      laserLabelEl.style.display = show ? 'block' : 'none';
    }

    function updateLaserBar() {
      if (laserCooldown <= 0) {
        laserBarFill.style.width = '100%';
      } else {
        laserBarFill.style.width = `${((LASER_COOLDOWN - laserCooldown) / LASER_COOLDOWN) * 100}%`;
      }
    }

    function makeBeam(origin, dir) {
      // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded)
      // Top is far end, bottom is origin. Make top much wider for dramatic cone effect.
      const beamGeo = new THREE.CylinderGeometry(0.7, 0.005, LASER_BEAM_LEN, 6, 1, true);
      const beamMat = new THREE.MeshBasicMaterial({
        color: 0xff2222,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
      });
      const beam = new THREE.Mesh(beamGeo, beamMat);
      const up = new THREE.Vector3(0, 1, 0);
      beam.quaternion.setFromUnitVectors(up, dir);
      beam.position.copy(origin).add(dir.clone().multiplyScalar(LASER_BEAM_LEN * 0.5));
      scene.add(beam);

      // Glow core (wider still, more transparent)
      const glowGeo = new THREE.CylinderGeometry(1.2, 0.015, LASER_BEAM_LEN, 6, 1, true);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.25,
        depthWrite: false,
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.quaternion.copy(beam.quaternion);
      glow.position.copy(beam.position);
      scene.add(glow);

      return { beam, glow };
    }

    function fireLaser() {
      const dir = aimDir.clone();
      const offsetDir = aimDir.clone().multiplyScalar(0.05);

      // Two beams â€” one from each eye, angled outward
      const originL = leftEyeWorld.clone().add(offsetDir);
      const originR = rightEyeWorld.clone().add(offsetDir);
      
      // Calculate outward spread directions based on eye positions relative to mid
      const eyeToEye = new THREE.Vector3().subVectors(rightEyeWorld, leftEyeWorld).normalize();
      
      // Left beam angles left (-eyeToEye), right beam angles right (+eyeToEye)
      const OUTWARD_ANGLE = 0.22;  // Increased spread from 0.18 to 0.22
      const dirL = dir.clone().add(eyeToEye.clone().multiplyScalar(-OUTWARD_ANGLE)).normalize();
      const dirR = dir.clone().add(eyeToEye.clone().multiplyScalar(OUTWARD_ANGLE)).normalize();

      const beamL = makeBeam(originL, dirL);
      const beamR = makeBeam(originR, dirR);

      // Point lights at each eye for red glow on face dots
      const flashL = new THREE.PointLight(0xff2222, 3, 1.5);
      flashL.position.copy(originL);
      scene.add(flashL);
      const flashR = new THREE.PointLight(0xff2222, 3, 1.5);
      flashR.position.copy(originR);
      scene.add(flashR);

      // Screen flash
      laserFlashEl.classList.add('flash');
      setTimeout(() => laserFlashEl.classList.remove('flash'), 120);

      // Fade out beams after LASER_VISIBLE_MS
      if (laserFadeTimer) clearTimeout(laserFadeTimer);
      laserFadeTimer = setTimeout(() => {
        [beamL, beamR].forEach(b => {
          scene.remove(b.beam); b.beam.geometry.dispose(); b.beam.material.dispose();
          scene.remove(b.glow); b.glow.geometry.dispose(); b.glow.material.dispose();
        });
        scene.remove(flashL); flashL.dispose();
        scene.remove(flashR); flashR.dispose();
        activeLaserMesh = null;
      }, LASER_VISIBLE_MS);

      // Cone-spread raycasting â€” fan of rays around each beam for forgiving hits
      // Increased spread angle to match the visually wider cone
      const SPREAD_ANGLE = 0.20;  // radians (~11.5Â°) half-cone - increased significantly
      
      const getSpreadDirs = (baseDir) => {
        const spreadDirs = [baseDir.clone()];
        const arbitrary = Math.abs(baseDir.y) < 0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
        const perp1 = new THREE.Vector3().crossVectors(baseDir, arbitrary).normalize();
        const perp2 = new THREE.Vector3().crossVectors(baseDir, perp1).normalize();
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const offset = perp1.clone().multiplyScalar(Math.cos(angle) * SPREAD_ANGLE)
                    .add(perp2.clone().multiplyScalar(Math.sin(angle) * SPREAD_ANGLE));
          spreadDirs.push(baseDir.clone().add(offset).normalize());
        }
        return spreadDirs;
      };

      const spreadDirsL = getSpreadDirs(dirL);
      const spreadDirsR = getSpreadDirs(dirR);

      const foodMeshes = [];
      for (const obj of gameObjects) {
        obj.mesh.traverse(child => {
          if (child.isMesh) foodMeshes.push({ child, obj });
        });
      }
      const allChildren = foodMeshes.map(f => f.child);

      // Try all spread rays from both eyes
      let hitObj = null;
      const beamConfigs = [
        { origin: originL, dirs: spreadDirsL, baseDir: dirL },
        { origin: originR, dirs: spreadDirsR, baseDir: dirR }
      ];
      
      outer:
      for (const config of beamConfigs) {
        for (const d of config.dirs) {
          laserRaycaster.set(config.origin, d);
          const intersects = laserRaycaster.intersectObjects(allChildren, false);
          if (intersects.length > 0) {
            const hitChild = intersects[0].object;
            hitObj = foodMeshes.find(f => f.child === hitChild)?.obj;
            if (hitObj && !hitObj.scored) break outer;
            hitObj = null;
          }
        }
      }

      // Proximity fallback â€” check if any food is close to either beam line
      if (!hitObj) {
        const PROX_RADIUS = 0.8;  // world units â€” doubled to match huge beams
        for (const config of beamConfigs) {
          for (const obj of gameObjects) {
            if (obj.scored) continue;
            const toFood = obj.mesh.position.clone().sub(config.origin);
            const along  = toFood.dot(config.baseDir);
            if (along < 0 || along > LASER_BEAM_LEN) continue;
            const closest = config.origin.clone().add(config.baseDir.clone().multiplyScalar(along));
            const dist = closest.distanceTo(obj.mesh.position);
            if (dist < PROX_RADIUS) {
              hitObj = obj;
              break;
            }
          }
          if (hitObj) break;
        }
      }

      if (hitObj && !hitObj.scored) {
        hitObj.scored = true;
        gameScore++;
        updateHUD();
        playBiteSound();
        const sp = worldToScreen(hitObj.mesh.position.x, hitObj.mesh.position.y);
        spawnScorePop(sp.x, sp.y);
        scene.remove(hitObj.mesh);
        disposeGroup(hitObj.mesh);
        gameObjects.splice(gameObjects.indexOf(hitObj), 1);
      }

      laserCooldown = LASER_COOLDOWN;
    }

    function tickLaser() {
      if (gameState !== 'playing') return;

      if (laserCooldown > 0) laserCooldown--;
      updateLaserBar();

      // Detect blink: either eye > threshold, with debounce (must open before next shot)
      const blinking = blinkLeft > BLINK_THRESHOLD || blinkRight > BLINK_THRESHOLD;
      if (!blinking) {
        blinkWasOpen = true;
      }
      if (blinking && blinkWasOpen && laserCooldown <= 0) {
        blinkWasOpen = false;
        fireLaser();
      }
    }

    function tickGame() {
      if (gameState !== 'playing') return;

      tickLaser();

      // Spawn
      spawnTimer++;
      if (spawnTimer >= spawnInterval) {
        spawnTimer = 0;
        spawnFood();
        // Gradually increase difficulty
        spawnInterval = Math.max(45, spawnInterval - 1);
        gameSpeed     = Math.min(0.028, gameSpeed + 0.00015);
      }

      // Bite detection â€” one bite per mouth-open gesture
      const mouthOpen = jawOpenScore > JAW_THRESHOLD;
      if (!mouthOpen) biteOnCooldown = false;

      const toRemove = [];
      for (const obj of gameObjects) {
        obj.mesh.position.x += obj.vx;
        obj.mesh.rotation.x += obj.spinX;
        obj.mesh.rotation.y += obj.spinY;
        obj.mesh.rotation.z += obj.spinZ;

        // Check if food is within mouth bounding box
        const fx = obj.mesh.position.x;
        const fy = obj.mesh.position.y;
        const inMouthX = Math.abs(fx - mouthWorldX) < mouthHalfW + 0.12;
        const inMouthY = Math.abs(fy - mouthWorldY) < mouthHalfH + 0.10;

        if (mouthOpen && !biteOnCooldown && inMouthX && inMouthY && !obj.scored) {
          // BITE!
          obj.scored     = true;
          biteOnCooldown = true;
          gameScore++;
          spawnInterval  = Math.max(45, spawnInterval - 2);
          updateHUD();
          playBiteSound();
          const sp = worldToScreen(fx, fy);
          spawnScorePop(sp.x, sp.y);
          toRemove.push(obj);
        } else if (Math.abs(fx) > 4.2 && !obj.scored) {
          // Missed â€” flew off screen
          obj.missed = true;
          gameLives--;
          updateHUD();
          triggerMissFlash();
          toRemove.push(obj);
          if (gameLives <= 0) {
            toRemove.forEach(o => { scene.remove(o.mesh); disposeGroup(o.mesh); });
            endGame();
            return;
          }
        } else if (Math.abs(fx) > 4.2 && obj.scored) {
          toRemove.push(obj);
        }
      }

      for (const obj of toRemove) {
        scene.remove(obj.mesh);
        disposeGroup(obj.mesh);
        gameObjects.splice(gameObjects.indexOf(obj), 1);
      }
    }

    // â”€â”€ Drop animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let dropping       = false;
    let dropVelocities = null;  // Float32Array, [vx, vy] per dot
    let dropCount      = 0;
    // At 60fps over 3s = 180 frames, a dot starting at yâ‰ˆ0 needs to reach yâ‰ˆ-6.
    // With constant gravity g: y = v0*t - 0.5*g*tÂ²  â†’  g â‰ˆ 2*6/180Â² â‰ˆ 0.00037 per frameÂ²
    // But we want it to feel snappy so we use a slightly higher value and let
    // each dot start with a tiny random downward nudge so they don't all leave at once.
    const GRAVITY = 0.0007;

    dropBtn.addEventListener('click', () => {
      const n = geometry.drawRange.count;
      if (n === 0) return;

      dropCount      = n;
      dropVelocities = new Float32Array(n * 2); // [vx, vy] per dot
      for (let i = 0; i < n; i++) {
        dropVelocities[i * 2 + 0] = (Math.random() - 0.5) * 0.012;  // gentle horizontal drift
        dropVelocities[i * 2 + 1] = (Math.random() * 0.01) - 0.005; // tiny initial vy scatter
      }

      latestLandmarks = null;  // stop face-tracking updates
      dropping        = true;
      dropBtn.disabled = true;
    });

    function stepDrop() {
      if (!dropping) return;
      let allGone = true;
      for (let i = 0; i < dropCount; i++) {
        const base = i * 3;
        dropVelocities[i * 2 + 1] -= GRAVITY;           // accelerate downward
        posArray[base + 0] += dropVelocities[i * 2 + 0];
        posArray[base + 1] += dropVelocities[i * 2 + 1];
        if (posArray[base + 1] > -8) allGone = false;    // off the bottom of view
      }
      geometry.attributes.position.needsUpdate = true;
      if (allGone) {
        dropping = false;
        geometry.setDrawRange(0, 0);
        geometry.attributes.position.needsUpdate = true;
        dropBtn.disabled = false;
      }
    }

    // â”€â”€ Render loop (always runs at display refresh rate) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      shaderMaterial.uniforms.time.value = time;

      if (!dropping && latestLandmarks) updateDots(latestLandmarks);
      if (dropping) stepDrop();
      tickGame();

      renderer.render(scene, camera);
    }
    animate();

    // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Warn on non-secure origins â€” camera requires HTTPS on mobile Safari/Chrome.
    // file:// and localhost are exempt. Always attempt to load the model; the
    // browser's own permission system will block the camera if needed.
    const isSecure = location.protocol === 'https:'
                  || location.protocol === 'file:'
                  || location.hostname === 'localhost'
                  || location.hostname === '127.0.0.1'
                  || location.hostname === '::1';
    if (!isSecure) {
      statusEl.textContent = 'warning: camera may need HTTPS on mobile';
      statusEl.style.color = '#ffaa44';
    }
    initDetector();
  </script>
</body>
</html>
