<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wigglydoom â€” hand banana</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <style>
    #status-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: rgba(255,255,255,0.7);
      padding: 0.25rem 0;
      flex-wrap: wrap;
    }
    #backend-badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      border: 1px solid #00ffff;
      color: #00ffff;
      border-radius: 2px;
    }
    #start-btn {
      border-color: #ffd700;
      color: #ffd700;
    }
    #start-btn:disabled { opacity: 0.5; cursor: default; }
    #gesture-display {
      font-size: 1.8rem;
      min-height: 2.2rem;
      text-align: center;
      letter-spacing: 0.1em;
      padding: 0.2rem 0;
    }
    #gesture-label {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.5);
      text-align: center;
      min-height: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-top: -0.25rem;
    }
    .back-link {
      color: cyan;
      font-size: 1rem;
      text-align: center;
      text-decoration-style: underline;
      text-decoration-thickness: 2px;
text-underline-offset:6px;

      margin-top: 0.25rem;
      position: absolute;
      left: 16px;
      top: 20%;
    }
    .back-link:hover { color: pink;
    text-decoration-thickness: 4px; }
  </style>
</head>
<body>
  <header>  <a class="back-link" href="index.html">â† wigglydoom</a>
    <h1>Hand Tracking</h1>
  </header>

  <div id="controls">
    <div id="status-bar">
      <span id="status-text">loading modelâ€¦</span>
      <span id="backend-badge" style="display:none">GPU</span>
    </div>

    <button id="start-btn" disabled>start camera</button>

    <label>
      <span>color</span>
      <select id="colorMode">
        <option value="rainbow">rainbow</option>
        <option value="pinkpurple">pink / purple</option>
        <option value="goldmagenta">gold / blue</option>
        <option value="cyanlime">cyan / lime</option>
      </select>
    </label>

    <label>
      <span>wiggle intensity</span>
      <input type="range" id="rippleIntensity" min="0" max="100" step="0.1" value="0">
    </label>

    <label>
      <span>wiggle speed</span>
      <input type="range" id="rippleSpeed" min="0" max="20" step="0.5" value="0">
    </label>

    <label>
      <span>gradient start</span>
      <input type="range" id="gradientStart" min="-4" max="4" step="0.1" value="-2">
    </label>

    <label>
      <span>gradient end</span>
      <input type="range" id="gradientEnd" min="-4" max="4" step="0.1" value="2">
    </label>

    <label>
      <span>dot size</span>
      <input type="range" id="pointSize" min="1" max="16" step="0.5" value="5">
    </label>

    <label>
      <span>dot density</span>
      <input type="range" id="dotDensity" min="0.1" max="40" step="0.1" value="15">
    </label>

    <label>
      <span>zoom</span>
      <input type="range" id="zoom" min="1" max="15" step="0.1" value="3">
    </label>

  
  </div>

  <video id="webcam" playsinline autoplay muted style="display:none"></video>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

  <script type="module">
    import { GestureRecognizer, FilesetResolver }
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

    // â”€â”€ Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // â”€â”€ Scene / Camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.z = 3;

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // â”€â”€ Wiggle shader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time:               { value: 0 },
        colorMode:          { value: 0 },
        rippleSpeed:        { value: 0.0 },
        rippleIntensity:    { value: 0.0 },
        gradientStart:      { value: -2.0 },
        gradientEnd:        { value: 2.0 },
        pointSize:          { value: 5.0 },
        expressionColor:    { value: new THREE.Color(0, 0, 0) },
        expressionStrength: { value: 0.0 },
      },
      vertexShader: /* glsl */`
        uniform float time;
        uniform float rippleSpeed;
        uniform float rippleIntensity;
        uniform float pointSize;

        varying vec3  vPosition;
        varying float vColorFactor;

        void main() {
          vPosition = position;

          float frequency  = 2.0;
          float waveHeight = 0.1 * rippleIntensity;
          float wave =
            sin(frequency * position.x + time * rippleSpeed) *
            sin(frequency * position.y + time * rippleSpeed) *
            sin(frequency * position.z + time * rippleSpeed);

          vec3 displaced = position * (1.0 + wave * waveHeight);
          vColorFactor   = wave;

          gl_Position  = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
          gl_PointSize = pointSize;
        }
      `,
      fragmentShader: /* glsl */`
        uniform float time;
        uniform int   colorMode;
        uniform float gradientStart;
        uniform float gradientEnd;
        uniform vec3  expressionColor;
        uniform float expressionStrength;

        varying vec3  vPosition;
        varying float vColorFactor;

        vec3 rainbow(float t) {
          vec3 a = vec3(0.5, 0.5, 0.5);
          vec3 b = vec3(0.5, 0.5, 0.5);
          vec3 c = vec3(1.0, 1.0, 1.0);
          vec3 d = vec3(0.00, 0.33, 0.67);
          return a + b * cos(6.28318 * (c * t + d));
        }

        void main() {
          vec2  coord = gl_PointCoord - vec2(0.5);
          float dist  = dot(coord, coord);
          if (dist > 0.25) discard;
          float alpha = 1.0 - smoothstep(0.04, 0.25, dist);

          float t = time * 0.5;
          vec3  color;

          if (colorMode == 0) {
            color = rainbow(vColorFactor + t);
          } else if (colorMode == 1) {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.5, 0.0, 1.0), vec3(1.0, 0.161, 0.765), g);
          } else if (colorMode == 2) {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.0, 0.522, 1.0), vec3(0.996, 0.788, 0.255), g);
          } else {
            float g = clamp(
              (vPosition.y - gradientStart) / (gradientEnd - gradientStart),
              0.0, 1.0
            );
            color = mix(vec3(0.0, 1.0, 1.0), vec3(0.5, 1.0, 0.0), g);
          }

          color = mix(color, expressionColor, expressionStrength);
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      depthWrite:  false,
    });

    // â”€â”€ Geometry pre-allocation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 21 landmarks per hand, up to 2 hands, up to 40Ã— density via barycentric
    const BASE_PER_HAND = 21;
    const MAX_HANDS     = 2;
    const MAX_COPIES    = 40;
    const MAX_BASE      = BASE_PER_HAND * MAX_HANDS;                        // 42
    const MAX_EXTRA     = BASE_PER_HAND * (MAX_COPIES - 1) * MAX_HANDS;    // 1638
    const MAX_POINTS    = MAX_BASE + MAX_EXTRA;                             // 1680

    const posArray = new Float32Array(MAX_POINTS * 3);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    geometry.setDrawRange(0, 0);

    // Pre-baked random values for stable barycentric extra dot positions
    const randBuf = new Float32Array(MAX_EXTRA * 5);
    for (let i = 0; i < randBuf.length; i++) randBuf[i] = Math.random();

    // Standard MediaPipe 21-landmark hand connections
    const HAND_CONNECTIONS = [
      {start:0,end:1},{start:1,end:2},{start:2,end:3},{start:3,end:4},      // thumb
      {start:0,end:5},{start:5,end:6},{start:6,end:7},{start:7,end:8},      // index
      {start:5,end:9},{start:9,end:10},{start:10,end:11},{start:11,end:12}, // middle
      {start:9,end:13},{start:13,end:14},{start:14,end:15},{start:15,end:16},// ring
      {start:13,end:17},{start:17,end:18},{start:18,end:19},{start:19,end:20},// pinky
      {start:0,end:17},                                                      // wristâ€“pinky
      {start:5,end:9},{start:9,end:13},{start:13,end:17},                   // knuckle line
    ];

    const handAdjacency = Array.from({ length: BASE_PER_HAND }, () => []);
    for (const { start, end } of HAND_CONNECTIONS) {
      handAdjacency[start].push(end);
      handAdjacency[end].push(start);
    }

    const dots = new THREE.Points(geometry, shaderMaterial);
    scene.add(dots);

    // â”€â”€ UI â†’ uniform wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const colorMap = { rainbow: 0, pinkpurple: 1, goldmagenta: 2, cyanlime: 3 };

    document.getElementById('colorMode').addEventListener('input', e => {
      shaderMaterial.uniforms.colorMode.value = colorMap[e.target.value] ?? 0;
    });
    document.getElementById('rippleIntensity').addEventListener('input', e => {
      shaderMaterial.uniforms.rippleIntensity.value = parseFloat(e.target.value) / 10.0;
    });
    document.getElementById('rippleSpeed').addEventListener('input', e => {
      shaderMaterial.uniforms.rippleSpeed.value = parseFloat(e.target.value);
    });
    document.getElementById('gradientStart').addEventListener('input', e => {
      shaderMaterial.uniforms.gradientStart.value = parseFloat(e.target.value);
    });
    document.getElementById('gradientEnd').addEventListener('input', e => {
      shaderMaterial.uniforms.gradientEnd.value = parseFloat(e.target.value);
    });
    document.getElementById('pointSize').addEventListener('input', e => {
      shaderMaterial.uniforms.pointSize.value = parseFloat(e.target.value);
    });

    let dotDensity = 15.0;
    document.getElementById('dotDensity').addEventListener('input', e => {
      dotDensity = parseFloat(e.target.value);
    });
    document.getElementById('zoom').addEventListener('input', e => {
      camera.position.z = parseFloat(e.target.value);
    });

    // â”€â”€ GestureRecognizer init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const statusEl  = document.getElementById('status-text');
    const badgeEl   = document.getElementById('backend-badge');
    const startBtn  = document.getElementById('start-btn');
    const gestureEl = document.getElementById('gesture-display');
    const labelEl   = document.getElementById('gesture-label');

    let gestureRecognizer = null;
    let modelReady        = false;

    async function initDetector() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );

        const modelOptions = {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
            delegate: "GPU",
          },
          runningMode:               "VIDEO",
          numHands:                   2,
          minHandDetectionConfidence: 0.5,
          minHandPresenceConfidence:  0.5,
          minTrackingConfidence:      0.5,
        };

        try {
          gestureRecognizer = await GestureRecognizer.createFromOptions(vision, modelOptions);
          badgeEl.textContent   = 'GPU';
          badgeEl.style.display = 'inline';
        } catch (_gpuErr) {
          console.warn('[hand-banana] GPU delegate failed, retrying with CPU', _gpuErr);
          modelOptions.baseOptions.delegate = "CPU";
          gestureRecognizer = await GestureRecognizer.createFromOptions(vision, modelOptions);
          badgeEl.textContent   = 'CPU';
          badgeEl.style.display = 'inline';
        }

        modelReady           = true;
        statusEl.textContent = 'ready â€” click start camera';
        startBtn.disabled    = false;

      } catch (err) {
        statusEl.textContent = 'model error: ' + err.message;
        console.error('[hand-banana] MediaPipe init failed', err);
      }
    }

    // â”€â”€ Webcam â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const video = document.getElementById('webcam');

    startBtn.addEventListener('click', async () => {
      startBtn.disabled    = true;
      startBtn.textContent = 'camera on';
      statusEl.textContent = 'requesting cameraâ€¦';
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' },
          audio: false,
        });
        video.srcObject = stream;
        video.play().catch(() => {});
        await new Promise(resolve => { video.onloadeddata = resolve; });
        statusEl.textContent = 'detectingâ€¦';
        detectionLoop();
      } catch (err) {
        statusEl.textContent = 'camera error: ' + err.message;
        startBtn.disabled    = false;
        startBtn.textContent = 'retry camera';
      }
    });

    // â”€â”€ Gesture â†’ color mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Each entry: emoji displayed, RGB color tint for the dots (null = no tint)
    const GESTURE_MAP = {
      'Closed_Fist': { emoji: 'âœŠ', label: 'fist',         color: [1.0, 0.1,  0.1 ] },
      'Open_Palm':   { emoji: 'ğŸ–', label: 'open',         color: null               },
      'Pointing_Up': { emoji: 'â˜ï¸', label: 'pointing up',  color: [0.6, 0.9,  1.0 ] },
      'Thumb_Down':  { emoji: 'ğŸ‘', label: 'thumb down',   color: [0.2, 0.3,  1.0 ] },
      'Thumb_Up':    { emoji: 'ğŸ‘', label: 'thumb up',     color: [1.0, 0.85, 0.1 ] },
      'Victory':     { emoji: 'âœŒï¸', label: 'peace',        color: [0.0, 1.0,  0.85] },
      'ILoveYou':    { emoji: 'ğŸ¤˜', label: 'rock on',      color: [1.0, 0.16, 0.76] },
      'None':        { emoji: '',   label: '',              color: null               },
    };

    let currentExprStrength  = 0.0;
    const currentExprColor   = new THREE.Color(0, 0, 0);
    const targetExprColor    = new THREE.Color(0, 0, 0);
    let   targetExprStrength = 0.0;

    function applyGestures(gestures, handedness) {
      let bestScore   = 0;
      let bestGesture = 'None';
      const emojis    = [];

      for (let h = 0; h < gestures.length; h++) {
        const g = gestures[h]?.[0];
        if (!g) continue;
        const entry = GESTURE_MAP[g.categoryName];
        if (entry?.emoji) emojis.push(entry.emoji);
        if (g.score > bestScore && g.categoryName !== 'None') {
          bestScore   = g.score;
          bestGesture = g.categoryName;
        }
      }

      gestureEl.textContent = emojis.join('  ');
      const best = GESTURE_MAP[bestGesture];
      labelEl.textContent   = (best && bestScore > 0.5) ? best.label : '';

      if (best?.color && bestScore > 0.5) {
        targetExprStrength = Math.min(bestScore * 0.9, 0.75);
        targetExprColor.setRGB(best.color[0], best.color[1], best.color[2]);
      } else {
        targetExprStrength = 0.0;
      }

      const lerp = 0.08;
      currentExprStrength += (targetExprStrength - currentExprStrength) * lerp;
      currentExprColor.lerp(targetExprColor, lerp);
      shaderMaterial.uniforms.expressionColor.value.copy(currentExprColor);
      shaderMaterial.uniforms.expressionStrength.value = currentExprStrength;
    }

    // â”€â”€ Inference loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let latestLandmarks = null;
    let lastVideoTime   = -1;
    let noHandCount     = 0;

    function detectionLoop() {
      if (modelReady && video.readyState >= 2 && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        try {
          const result = gestureRecognizer.recognizeForVideo(video, performance.now());
          if (result.landmarks && result.landmarks.length > 0) {
            latestLandmarks      = result.landmarks;
            noHandCount          = 0;
            statusEl.textContent = 'detectingâ€¦';
            applyGestures(result.gestures, result.handedness);
          } else {
            noHandCount++;
            gestureEl.textContent = '';
            labelEl.textContent   = '';
            if (noHandCount === 30) statusEl.textContent = 'no hands detected';
            if (noHandCount > 60) {
              latestLandmarks = null;
              geometry.setDrawRange(0, 0);
              geometry.attributes.position.needsUpdate = true;
              targetExprStrength = 0.0;
            }
          }
        } catch (_) {
          // Per-frame errors ignored
        }
      }
      requestAnimationFrame(detectionLoop);
    }

    // â”€â”€ Landmark â†’ Three.js world coordinates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Same aspect-ratio correction as face-dots: multiply x by video aspect so
    // hand proportions are accurate regardless of camera resolution.
    function updateDots(allHandLandmarks) {
      let count     = 0;
      let extraSlot = 0;

      const videoAspect = (video.videoWidth && video.videoHeight)
        ? video.videoWidth / video.videoHeight
        : 4 / 3;

      for (const landmarks of allHandLandmarks) {
        if (dotDensity <= 1.0) {
          const stride = 1 / dotDensity;
          for (let f = 0; f < landmarks.length; f += stride) {
            const lm = landmarks[Math.floor(f)];
            posArray[count * 3 + 0] =  (0.5 - lm.x) * 4 * videoAspect;
            posArray[count * 3 + 1] =  (0.5 - lm.y) * 4;
            posArray[count * 3 + 2] = -lm.z           * 4;
            count++;
          }
        } else {
          // Base landmarks
          for (let i = 0; i < landmarks.length; i++) {
            const lm = landmarks[i];
            posArray[count * 3 + 0] =  (0.5 - lm.x) * 4 * videoAspect;
            posArray[count * 3 + 1] =  (0.5 - lm.y) * 4;
            posArray[count * 3 + 2] = -lm.z           * 4;
            count++;
          }

          // Barycentric super-sample across hand mesh triangles
          const extraCount = Math.min(
            Math.floor((dotDensity - 1) * landmarks.length),
            BASE_PER_HAND * (MAX_COPIES - 1)
          );

          for (let e = 0; e < extraCount && count < MAX_POINTS; e++, extraSlot++) {
            if (extraSlot >= MAX_EXTRA) break;
            const rb   = extraSlot * 5;
            const i    = Math.floor(randBuf[rb]     * landmarks.length) % landmarks.length;
            const nbrs = handAdjacency[i];
            if (!nbrs || nbrs.length < 2) continue;

            const ni = Math.floor(randBuf[rb + 1] * nbrs.length) % nbrs.length;
            let   nj = Math.floor(randBuf[rb + 2] * (nbrs.length - 1)) % (nbrs.length - 1);
            if (nj >= ni) nj++;

            const a = landmarks[i];
            const b = landmarks[nbrs[ni]];
            const c = landmarks[nbrs[nj]];

            const sqR = Math.sqrt(randBuf[rb + 3]);
            const t1  = 1 - sqR;
            const t2  = sqR * (1 - randBuf[rb + 4]);
            const t3  = sqR *      randBuf[rb + 4];

            posArray[count * 3 + 0] =  (0.5 - (a.x*t1 + b.x*t2 + c.x*t3)) * 4 * videoAspect;
            posArray[count * 3 + 1] =  (0.5 - (a.y*t1 + b.y*t2 + c.y*t3)) * 4;
            posArray[count * 3 + 2] = -(      a.z*t1 + b.z*t2 + c.z*t3)    * 4;
            count++;
          }
        }
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.setDrawRange(0, count);
    }

    // â”€â”€ Render loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      shaderMaterial.uniforms.time.value = time;
      if (latestLandmarks) updateDots(latestLandmarks);
      renderer.render(scene, camera);
    }
    animate();

    // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const isSecure = location.protocol === 'https:'
                  || location.protocol === 'file:'
                  || location.hostname === 'localhost'
                  || location.hostname === '127.0.0.1'
                  || location.hostname === '::1';
    if (!isSecure) {
      statusEl.textContent = 'warning: camera may need HTTPS on mobile';
      statusEl.style.color = '#ffaa44';
    }
    initDetector();
  </script>
</body>
</html>
